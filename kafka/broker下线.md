首先要知道，一个broker会扮演哪些角色

### kafka的主控制器
每个broker启动时，都会向zk的/controller注册一个临时节点，同时监听该节点的状态变化。第一个注册成功的被选举为主控制器，之后通过发送心跳包刷新会话以保持与zk的连接。
**主控制器主要负责：**
- 

当broker下线，zk收不到心跳包，会话超时则会删除临时节点。其他broker监听到主控制器下线后，会尝试重新注册临时节点。

### kafka的组协调器
内部的topic \_consumer_offset用来保存消费组的offset，并且存在50个分区，这些分区都分布在不同的broker上。消费组根据算法选出其中一个分区，该分区的主副本所在的broker则作为消费组的组协调者。
**组协调器主要负责:**
- 


当组协调器下线，主控制器会通过监听的zk节点的状态发生变化而收到通知，控制器选举出新的组协调器，发送leaderandisr给topic下所有broker，节点更新分区的状态信息（目的是告诉这些broker自己是什么角色）。控制器再发送updatemetadata给每个节点，更新元数据缓存（目的是用于以后的协调者发现功能）。


当消费组发送请求给重新上线的组协调者，消费者会收到一个“不是组协调者”的响应。消费者会向其他broker发送请求重新获取组协调者，这就是组协调者发现机制。

<font color="red">注意1：</font> 什么时候会发生broker响应“不是组协调者”？
组协调者下线，控制器重新选举出新的组协调者，当旧的组协调者上线，接收到消费组的请求时，就会响应“不是组协调者”。

### 分区leader副本
如果下线的broker上存在某个分区的主副本，那么组协调者需要修改分区状态为下线，修改该broker上的副本状态为下线。
在isr(找不到就找ar)中重新选举主副本，将最新的isr和主副本信息更新到zk中，并且发送leaderandisr给分区的所有存活副本，以更新元数据，分区状态修改为上线。
消费者通过pull消息时，响应结果中所携带的元数据，或者当元数据超时，主动发送更新元数据请求到组协调者，可以知道最新的主副本。
。。。

### 分区follower副本